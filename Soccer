So moving on to the soccer box, with the nmap scan we identify ports 22, 80, and 9091. The service coming back on port 9091 is xmltec-xmlmail, which I’m not entirely sure about. As far as I know now, this is nmap trying to assign a possible service to something it doesn’t recognize. Oh well, let’s move on to looking at the webpage. When we load it up, it’s a simple blog with a few small boxes of text. The page source doesn’t seem to reveal anything interesting, so we move on to dirbuster. This run reveals two folders, /tiny/ and /tiny/uploads. The uploads folder is blocked, but the /tiny/ folder gives us a login page. My first guess was to pull up the documentation and enter the default username and password of admin and admin@123. Once logged in, I looked through the files hosted on the site and came to find one that was called tinyfilemanager.php. Opening this file tells us that we’re dealing with a TFM version 2.4.3. It also gives us a username and password for a standard user and some emails. It’s worth keeping in mind but possibly not necessary here. The main thing to know is that TFM 2.4.3 has an exploit where users can upload malicious php files to the server and achieve RCE. All we have to do is use a standard php reverse shell script. Upload the script to the tinyfilemanager system then go to the url for it, which should be ‘ip’/tiny/uploads/exploit.php. Make sure you have nc listening on your end when you run it! Once this is done, you’ll be given the shell and logged in as user www-data. Feel free to use extra commands here to improve your shell experience. Now we can find that the user.txt file is within /home/player/user.txt, but since we’re logged in as www-data, we don’t have access to read the file. We’ll have to move laterally into the player account to get this data. When I go to look at the nginx folder, I find /etc/nginx/sites-enabled. When I open this directory, I find that there is a default, but also a soc-player.htb file. When I cat this file, I find that it has a server name of soc-player.soccer.htb. Well, wfuzz wasn’t working earlier, so finding this manually was a big help lol. Guess we finally found what was on port 9091. Either way, let’s add this to our hosts file and see what we’re working with. Looks like it’s a webpage that users can interact with. It’s got a login and signup page. I made a fake account with test as every input (test@test.com as well). Didn’t notice too much in burp, they’ve got a cookie, along with some input parameters that don’t appear to be injectable. When I log in to the website, I get a free ticket and am given an id for it. I’m just gonna jot that down because it’s probably important. When I hit enter here, it says “ticket exists”, but if I change the number, I get an error saying the ticket doesn’t exist. Ok, this seems injectable. I come to you now some time much later than I last typed in this document. It appears that manual sql injection on this site is proving difficult. Since I’m training for the OSCP, I wanted to avoid SQLMap, but alas I have no other option. Either way, use sqlmap with this command: sqlmap -u "ws://soc-player.soccer.htb:9091"  --data '{"id": "inject"}' --dbms mysql -D soccer_db --dump --level 3 --risk 3. This will get you the account player and its password. Back in the victim machine, use su player to login to player. The next thing is that we cannot run ‘sudo -l’ on the shell script, says no can do when I try. Well ok then, guess we gotta look for setuid files instead. Run the good old ‘find / -perm /4000 2>/dev/null’ script to find a list of setuid files. Apparently sudo is a setuid file, but since we don’t have the ability to run it, this won’t work. What may work, however, is doas, which is a Debian equivalent to sudo. Next we need to find doas.conf, which is pretty easy with the find command. However, since we can’t use sudo in the shell script, we need to ssh into the system. Just ssh into the ip as player and enter the password. Next, open /usr/local/etc/doas.conf. Within the file, we see that we can use dstat without a password as root, when using doas. I wasn’t quite sure if there was a way to exploit this one, so I googled it. Found a web page that talked about how you can import plugins to dstat through usr/local/share/dsat/dstat_’exploitname’.py. So what we should do next is create a python file in that directory that spawns a script. In the script, import os, then os.system(“/bin/bash”). From here, doas /usr/bin/dstat -- ’exploitName’ to run the exploit and get root. Congrats! This was a long one. 
